<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>woscilloscope</title>
    <style>
html { background: black; }
body { width:800px;margin:auto; }
audio {width: 800px;}
    </style>
    <script src="gl.js"></script>
    <script>
'use strict';
let audioCtx = new AudioContext();
let search = location.search.substr(1).split('&');
let audioUrl = search[0] ? './' + search[0] : './khrang.m4a';
let flags = +search[1];
let audioData = null;
let quadIndex = null;
let vertexIndex = null;
const nSamples = 2048;

function axhr(url, callback, progress) {
    let request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onprogress = progress;
    request.onload = function() {
        audioCtx.decodeAudioData(request.response, function(buffer) {
            callback(buffer);
        });
    }
    request.send();
}

window.onload = function() {
    let canvas = $('c'),
        gl = initGl(canvas),
        shader = CreateShader(gl, getText('vshader'), getText('fshader'));

    let position = 0;
    let loop = function() {
        draw(gl, shader);
        requestAnimationFrame(loop);
    }
    axhr(audioUrl, function(buffer) {
        $('htmlAudio').volume = 0.5;
        $('htmlAudio').src = audioUrl;
        //$('htmlAudio').play();
        quadIndex = makeQuadIndex(gl);
        vertexIndex = makeVertexIndex(gl);
        audioData = prepareAudioData(gl, buffer);
        loop();
    }, function(e) {
        console.log('progress: ' + e.loaded + ' / ' + e.total);
    });
};

function initGl(canvas) {
    let gl = canvas.getContext('webgl');
    gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
    gl.viewport(0, 0, canvas.width, canvas.height);
    return gl;
}

function makeQuadIndex(gl) {
    let index = new Int32Array(nSamples/2);
    for (let i = index.length; i--; ) {
        index[i] = 0x03020100;
    }
    let vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, index, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    return vbo;
}
function makeVertexIndex(gl) {
    let len = (nSamples-1)*2*3,
        index = new Uint16Array(len);
    for (let i = 0, pos = 0; i < len; ) {
        index[i++] = pos;
        index[i++] = pos+2;
        index[i++] = pos+1;
        index[i++] = pos+1;
        index[i++] = pos+2;
        index[i++] = pos+3;
        pos += 4;
    }
    let vbo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, index, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    return vbo;
}

function prepareAudioData(gl, buffer) {
    let left = buffer.getChannelData(0),
        right = buffer.getChannelData(1);

    if (flags&1) {
        let tmp = left;
        left = right;
        right = tmp;
    }

    let vbo = gl.createBuffer();
    return {
        vbo: vbo,
        left: left,
        right: right,
    };
}

function loadWaveAtPosition(gl, position) {
    position = Math.floor(position*44100);
    let end = Math.min(audioData.left.length, position+nSamples) - 1,
        len = end - position;
    let subArr = new Float32Array(nSamples*4),
        left = audioData.left,
        right = audioData.right;
    for (let i = 0; i < len; i++) {
        let t = i*8,
            p = i+position;
        subArr[t]   = subArr[t+2] = subArr[t+4] = subArr[t+6] = left[p];
        subArr[t+1] = subArr[t+3] = subArr[t+5] = subArr[t+7] = right[p];
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, audioData.vbo);
    gl.bufferData(gl.ARRAY_BUFFER, subArr, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
}

function $(id) { return document.getElementById(id); }

function getText(id) { return $(id).innerText; }

function draw(gl, shader) {
    loadWaveAtPosition(gl, $('htmlAudio').currentTime);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(shader);
    {
        let tmpPos = gl.getUniformLocation(shader, 'uInvert');
        if (tmpPos && tmpPos !== -1) {
            gl.uniform1f(tmpPos, (flags & 2) ? -1 : 1);
        }
    }

    let attribs = [];

    {
        gl.bindBuffer(gl.ARRAY_BUFFER, quadIndex);
        let idxAttr = gl.getAttribLocation(shader, 'aIdx');
        if (idxAttr > -1) {
            gl.enableVertexAttribArray(idxAttr);
            gl.vertexAttribPointer(idxAttr, 1, gl.BYTE, false, 1, 0);
            attribs.push(idxAttr);
        }
    }

    {
        gl.bindBuffer(gl.ARRAY_BUFFER, audioData.vbo);
        let tmpPos = gl.getAttribLocation(shader, 'aStart');
        if (tmpPos > -1) {
            gl.enableVertexAttribArray(tmpPos);
            gl.vertexAttribPointer(tmpPos, 2, gl.FLOAT, false, 8, 0);
            attribs.push(tmpPos);
        }

        tmpPos = gl.getAttribLocation(shader, 'aEnd');
        if (tmpPos > -1) {
            gl.enableVertexAttribArray(tmpPos);
            gl.vertexAttribPointer(tmpPos, 2, gl.FLOAT, false, 8, 8*4);
            attribs.push(tmpPos);
        }
    }


    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndex);
    gl.drawElements(gl.TRIANGLES, (nSamples-1)*2, gl.UNSIGNED_SHORT, 0);
    //gl.drawArrays(gl.TRIANGLES, 0, nSamples-1);

    for (let a of attribs) {
        gl.disableVertexAttribArray(a);
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.useProgram(null);
}
    </script>
    <script language="x-shader/x-vertex" id="vshader">
#define EPS 1E-6
uniform float uInvert;
precision highp float;
attribute vec2 aStart, aEnd;
attribute float aIdx;
varying vec2 vStart, vEnd;
varying float vLen;
float size = 100.;
void main () {
    vStart = aStart;
    vEnd = aEnd;

    float tang;
    vec2 current;
    if (aIdx >= 2.0) {
        current = aEnd;
        tang = 1.0;
    } else {
        current = aStart;
        tang = -1.0;
    }
    float side = (mod(aIdx, 2.0)-0.5)*2.0;

    vec2 dir = aEnd-aStart;
    vLen = length(dir);
    vec2 delta;
    if (vLen > EPS) {
        dir = dir / vLen;
    } else {
        dir = vec2(0.0, 1.0);
    }
    vec2 norm = vec2(-dir.y, dir.x);
    gl_Position = vec4((current+(tang*dir+norm*side)/size*5.0)*uInvert,0.0,1.0);
    //gl_PointSize = 20.0;
}
    </script>
    <script language="x-shader/x-fragment" id="fshader">
precision highp float;
varying vec2 vStart, vEnd;
varying float vLen;
void main (void)
{
    //float alpha = uva.z * exp(-uva.x*uva.x);
    float alpha = 0.01/vLen;
    gl_FragColor = vec4(0.03, 1.0, 0.03, alpha);
}
    </script>
</head>
<body style="width:800px;margin:auto;">
<canvas id="c" width=800 height=800></canvas><br>
<audio controls src="./khrang.m4a" id="htmlAudio" style="width:800px">
</body>
</html>
